---
title: Redis 数据持久化
---
我们知道Redis的数据是保存在内存里的，如果突然宕机，数据就会全部丢失，因此Redis必须要有一种持久化的机制来保证不会因为故障而丢失。有两个方式，一种是快照，以各种AOF日志。
#### 快照
简单的来说，就是Redis在接受客户端请求的同时，还需要进行内存快照，快照就需要进行文件IO操作，但是IO操作会严重拖垮服务器性能，所以为了不阻塞线上的业务员，就需要边持久化数据边响应客户端的请求。
Redis是单线程程序，那么在服务客户端的同时，会创建一个新的进程来进行持久化的操作。就是说，主进程继续服务于客户端，子进程继续快照持久化。具体的采用了那种形式来创建子进程呢？在现在操作系统中，都是采用的**写实复制（copy-on-write COW）**，而不是对父进程空间进行整体复制。
整个过程就是子进程做数据持久，它不会修改现有的内存数据结构，只是对内存的数据结构遍历读取然后序列化到磁盘中。父进程持续响应客户端的请求，对内存的数据结构修改。当父进程对内存数据进行修改是，像**COW**机制一样，会先复制一份，然后对复制的页面进行修改，这时子进程得到的数据还是在创建子进程一瞬间的数据。
#### AOF
AOF日志存储就是说把所有Redis的修改命令记录到日志中，需要恢复的时候直接把日志中的所有记录顺序执行即可。
AOF日志的时间点是在执行完命令之后，也就是Redis会先把命令执行之后再存储到AOF日志中。
这样也会有一个问题，就是Redis运行的时间越长，日志就会越来越庞大，那么当我们在恢复日志的时候就会非常耗时，所以Redis也提供了AOF日志瘦身的机制。
##### AOF重写
Redis提供了`bgrewriteaof`指令用于对AOF日志进行瘦身，原理很简单，就是创建一个新进程，把所有的内存数据遍历然后转换成一些列的Redis指令，序列化到一个新的AOF日志中，完成之后再把这段时间的AOF日志增量同步到新的AOF日志中，这样就可以替代旧的AOF日志。